package io.kzw.advance._02_bit_hex;

/**
 * Java位运算使用.
 *
 * @author kzw on 2018/09/15.
 */
public final class _03_Bit {

    /*
     * ###### 前言
     *
     * 日常开发中位运算不是很常用，但是巧妙的使用位运算可以大量减少运行开销，优化算法。
     * 举个例子，翻转操作比较常见，比如初始值为1，操作一次变为0，再操作一次变为1。
     * 可能的做法是使用三木运算符，判断原始值为1还是0，如果是1，设置为0，否则设置为0.
     *
     * 但是使用位运算，不用判断原始值，直接改变值就可以：
     *
     * 1^num // num为原始值
     *
     * 当然，一条语句可能对代码没什么影响，但是在高重复，大数据量的情况下将会节省很多开销。
     *
     * 以下是自己整理的关于java位运算的部分内容，如有错误，还请指出，以共同进步，先行致谢。
     */
    private static void reverse() {
        int number = 1;
        for (int i = 0; i < 5; i++) {
            number = 1 ^ number;
            /*
             * 0
             * 1
             * 0
             * 1
             * 0
             */
            System.out.println(number);
        }
    }

    /*
     * ###### java支持的位运算符
     *
     * &：按位与。
     *
     * |：按位或。
     *
     * ~：按位非。
     *
     * ^：按位异或。
     *
     * <<：左位移运算符。
     *
     * >>：右位移运算符。
     *
     * <<<：无符号右移运算符。
     *
     * 位运算符中, 除～以外, 其余均为二元运算符。操作数只能为整型和字符型数据。
     *
     * Java使用 补码 来表示二进制数, 在补码表示中, 最高位为符号位, 正数的符号位为0, 负数为1。
     *
     * 补码的规定如下:
     *
     * 一、正整数的原码、反码、补码完全一样，即符号位固定为0，数值位相同
     * 二、负整数的符号位固定为1，由原码变为补码时，规则如下：
     *    1、原码符号位1不变，整数的每一位二进制数位求反，得到反码
     *    2、反码符号位1不变，反码数值位最低位加1，得到补码
     *
     *
     * 00000000000000000000000000000001  (-1)
     * 为何有那么多0、1，java中int是32位的。
     */

    /*
     * ###### 按位&
     *
     * 按位与的运算规则:
     * 0 0 1 1
     *    &
     * 0 1 0 1
     *    |
     *
     * 0 0 0 1
     *
     * 规则总结：只有两个操作数对应位同为1时，结果为1，其余全为0. （或者是只要有一个操作数为0，结果就为0）。
     */
    private static void test01() {
        /*
         * 10 & 12
         *
         * 10 % 2 = 5..0
         * 5 % 2 = 2..1
         * 2 % 2 = 1..0
         * 1 % 2 = 0..1
         * - 1010
         *
         * 同理：12 -> 1100
         *
         * 1010 & 1100 = 1000
         * 转成10进制：1*2^3 + 0*2^2 + 0*2^1 + 0*2^0 = 8
         */
        System.out.println("10 & 12 = " + (10 & 12));

        /*
         * -6 & -2
         *
         * 以补码来存储，比如以8位的-6来表示，也可以是16位的，前面补1即可，凑足16位。
         *
         * -6:
         * 6 % 2 = 3..0
         * 3 % 2 = 1..1
         * 1 % 2 = 0..1
         * ---110
         *
         * 然后8位的来表示的话，前面补0，00000110
         * 取反，11111001, +1: 11111010，如果要表示成32位的，补1
         *
         * 得表示的二进制补码：11111111111111111111111111111010
         *
         * -2:
         * 2 % 2 = 1..0
         * 1 % 2 = 0..1
         * ---10
         * 00000010，取反: 11111101, +1: 11111110
         * 表示成32位：11111111111111111111111111111110
         *
         * 11111111111111111111111111111010
         *                &
         * 11111111111111111111111111111110
         *                =
         * 11111111111111111111111111111010
         *
         * 此时符号位为1，结果为反码，想求原码，需要-1取反
         * 11111111111111111111111111111001
         * 00000000000000000000000000000110
         * = 6
         * 加上符号位：-6，最终结果为-6
         */
        System.out.println("-6 & -2 = " + (-6 & -2));
    }

    /*
     * ###### 按位|
     *
     * 按位或的运算规则：
     * 0011
     *   |
     * 0101
     *   =
     * 0111
     *
     * 规则总结：只有两个操作数对应位同为0时，结果为0，其余全为1.（或者是只要有一个操作数为1，结果就为1）。
     */
    private static void test02() {
        /*
         * 6 | 12
         *
         * 1010 | 1100 = 1110 = 14
         */
        System.out.println("10 | 12 = " + (10 | 12));
    }

    /*
     * ###### 按位～（取反）
     *
     * 按位非的运算规则：
     * ~01 = 10
     */
    private static void test03() {
        System.out.println("~6 = " + (~6));
    }

    /*
     * ###### 按位^（异或）
     *
     * 按位异或的运算规则：两位不同时才为1，相同时为0
     * 0011
     *  ^
     * 0101
     *  =
     * 0110
     */
    private static void test04() {
        /*
         * 6 ^ 12
         *
         * 1010 ^ 1100 = 0110 = 6
         */
        System.out.println("10 ^ 12 = " + (10 ^ 12));
    }

    /*
     * ###### 左位移（<<）
     *
     * 规则：
     * 1）丢弃最高位，低位补0；
     * 2）如果移动位数超过了该类型的最大位数，那么编译器会对移动的位数取模操作；
     * 3）在没有溢出的情况下，对于正数和负数都相当于乘2操作；
     * 4）如果移近高级位（32/64）,那么该值将变为负数；
     */
    private static void test05() {
        /*
         * 2 << 2 = 8
         *
         * 00000010 << 2 = 00001000 = 1 * 2^3 = 8
         */
        System.out.println("2 << 2 = " + (2 << 2));
    }

    /*
     * ###### 右位移（>>）
     *
     * 规则：
     * 1）丢弃低位，高位补符号位；(负数补1，正数补0);
     * 2）对于正数和负数都相当于除2操作；
     */
    private static void test06() {
        /*
         * -6 >> 2 = -2
         *
         * -6：
         * 6 % 2 = 3..0
         * 3 % 2 = 1..1
         * 1 % 2 = 0..1
         *
         * 00000110，取反：11111001, +1 = 11111010
         *
         * -6的二进制补码为:11111010（在计算机里存储用的反码）
         *
         * 11111010>>2 = 11111110
         *
         * 注意：此时高位为1，为负数，需要取其原码才能得到它的值，如果高位为0，则不用。
         *
         * 负数求原码：-1再取反
         * -1: 11111101
         * ~: 00000010
         *
         * 得到原码：00000010 = 2
         *
         * 加上符号位: -2
         */
        System.out.println("-6 >> 2 = " + (-6 >> 2));
    }

    /*
     * ###### 无符号右移（>>>）
     *
     * 低位移除，高位补0。
     * 注意，无符号右移（>>>）中的符号位（最高位）也跟着变，无符号的意思是将符号位当作数字位看待。
     * 如：-1>>>1结果为2147483647。这个数字应该比较熟悉，看两个输出语句就知道是什么了：
     *
     * System.out.println(Integer.toBinaryString(-1>>>1));
     * System.out.println(Integer.toBinaryString(Integer.MAX_VALUE));
     *
     * 输出结果为：
     * 1111111111111111111111111111111
     * 1111111111111111111111111111111
     *
     * -1>>>1竟然得到了int所能表示的最大整数，精彩。
     *
     * 除了使用-1>>>1能得到Integer.MAX_VALUE，以下的也能得到同样的结果：
     * //maxInt
     * System.out.println(~(1 << 31));
     * System.out.println((1 << -1)-1);
     * System.out.println(~(1 << -1));
     * 使用位运算往往能很巧妙的实现某些算法完成一些复杂的功能。
     */
    private static void test07() {
        /*
         * -6 >>> 2
         *
         * -6：
         * 6 % 2 = 3..0
         * 3 % 2 = 1..1
         * 1 % 2 = 0..1
         *
         * 00000000000000000000000000000110，取反：11111111111111111111111111111001, +1 = 11111111111111111111111111111010
         *
         * -6的二进制补码为:11111111111111111111111111111010（在计算机里存储用的反码）
         *
         * 11111111111111111111111111111010>>>2 = 00111111111111111111111111111110 = 1073741822
         *
         * 为什么上面 -6 >> 2位，与这边-6>>>2，一个用8位表示，一个用32位表示，其实int应该用32位表示，
         * 但是上面 -6 >> 2，补位完后高位为1，需要重新取反，而这边高位为1，结果无需取反。
         */
        System.out.println("-6 >>> 2 = " + (-6 >>> 2));
    }

    public static void main(String[] args) {
        // reverse();
        // test01();
        // test02();
        // test03();
        // test04();
        // test05();
        // test06();
        // test07();
    }
}
