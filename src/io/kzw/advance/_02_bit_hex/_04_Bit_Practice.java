package io.kzw.advance._02_bit_hex;

/**
 * 位运算使用.
 *
 * @author kzw on 2018/09/15.
 */
public final class _04_Bit_Practice {

    /*
     * ###### [常见使用] 1. m * 2^n
     *
     * 可以使用m<<n求得结果，如：
     * System.out.println("2^3=" + (1<<3));//2^3=8
     * System.out.println("3*2^3=" + (3<<3));//3*2^3=24
     *
     * 计算结果是不是很正确呢？如果非要说2<<-1为什么不等于0.5，前面说过，位运算的操作数只能是整型和字符型。
     * 在求int所能表示的最小值时，可以使用:
     *
     * // minInt
     * System.out.println(1 << 31);
     * System.out.println(1 << -1);
     *
     * 可以发现左移31位和-1位所得的结果是一样的，同理，左移30位和左移-2所得的结果也是一样的。
     * 移动一个负数位，是不是等同于右移该负数的绝对值位呢？输出一下就能发现不是的。java中int所能表示的最大数值是31位，加上符号位共32位。
     * 在这里可以有这样的位移法则：
     *
     * 法则一：任何数左移（右移）32的倍数位等于该数本身。
     * 法则二：在位移运算m<<n的计算中，若n为正数，则实际移动的位数为n%32，若n为负数，则实际移动的位数为(32+n%32)，右移，同理。
     *
     * 左移是乘以2的幂，对应着右移则是除以2的幂。
     */
    private static void test01() {
        // 2^3=8
        System.out.println("2^3=" + (1 << 3));
        // 3*2^3=24
        System.out.println("3*2^3=" + (3 << 3));
        // -8
        System.out.println("-1 << 3=" + (-1 << 3));
        // 1
        System.out.println("1 >> 32=" + (1 >> 32));
        // 1
        System.out.println("1 >> 0=" + (1 >> 0));
        // 0
        System.out.println("1 >> 31=" + (1 >> 31));
        // 0
        System.out.println("1 >> -1=" + (1 >> -1));
        // 0
        System.out.println("1 >> 30=" + (1 >> 30));
        // 0
        System.out.println("1 >> -2=" + (1 >> -2));
    }

    /*
     * ###### [常见使用] 2. 判断一个数的奇偶性
     *
     * n & 1 == 1 ? ”奇数” : ”偶数”
     *
     * 为什么与1能判断奇偶？所谓的二进制就是满2进1，那么好了，偶数的最低位肯定是0（恰好满2，对不对？），
     * 同理，奇数的最低位肯定是1.int类型的1，前31位都是0，无论是1&0还是0&0结果都是0，那么有区别的就是1的最低位上的1了，
     * 若n的二进制最低位是1（奇数）与上1，结果为1，反则结果为0.
     */
    private static void test02(int n) {
        System.out.println(n + "是 : " + ((n & 1) == 1 ? "奇数" : " 偶数"));
    }

    /*
     * ###### [常见使用] 3. 不用临时变量交换两个数
     *
     * 其实java中的异或运算法则完全遵守数学中的计算法则：
     * ①    a ^ a =0
     * ②    a ^ b =b ^ a
     * ③    a ^b ^ c = a ^ (b ^ c) = (a ^ b) ^ c;
     * ④    d = a ^b ^ c 可以推出 a = d ^ b ^ c.
     * ⑤    a ^ b ^a = b.
     */
    private static void test03() {
        int a = 3;
        int b = 4;
        a = a ^ b;
        b = b ^ a; // b = b ^ (a ^ b) --> b = a
        a = a ^ b; // (a ^ b) ^ (b ^ (a ^ b)) --> a = b
        // a = 4, b = 3
        System.out.println("a = " + a + " ,b = " + b);
    }

    /*
     * ###### [常见使用] 4. 取绝对值
     *
     * (a^(a>>31))-(a>>31)
     *
     * 先整理一下使用位运算取绝对值的思路：若a为正数，则不变，需要用异或0保持的特点；
     * 若a为负数，则其补码为源码翻转每一位后+1，先求其源码，补码-1后再翻转每一位，此时需要使用异或1具有翻转的特点。
     *
     * 任何正数右移31后只剩符号位0，最终结果为0，任何负数右移31后也只剩符号位1，溢出的31位截断，空出的31位补符号位1，
     * 最终结果为-1.右移31操作可以取得任何整数的符号位。
     *
     * 那么综合上面的步骤，可得到公式。a>>31取得a的符号，若a为正数，a>>31等于0，a^0=a，不变；若a为负数,a>>31等于-1 ，a^-1翻转每一位.
     */
    private static void test04(int n) {
        System.out.println(n + "的绝对值 = " + ((n ^ (n >> 31)) - (n >> 31)));
    }

    /*
     * ###### [常见使用] 5. 如何快速求取一个整数的7倍？
     *
     * (x<<3)-x
     */
    private static void test05(int n) {
        System.out.println(n + "的7倍 = " + ((n << 3) - n));
    }

    /*
     * ###### [常见使用] 6. 如何实现位操作求两个数的平均值?
     *
     * (x&y)+((x^y)>>1)
     */
    private static void test06(int x, int y) {
        System.out.println(x + "和" + y + "的平均值 = " + ((x & y) + ((x ^ y) >> 1)));
    }

    public static void main(String[] args) {
        // test01();
        // test02(3);
        // test02(10);
        // test03();
        // test04(-10);
        // test05(7);
        // test06(3,5);
    }
}
