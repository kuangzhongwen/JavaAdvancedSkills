package io.kzw.advance._02_bit_hex;

/**
 * Java中的进制详解.
 *
 * @author kzw on 2018/09/15.
 */
public final class _02_Hex_Practice {

    /*
     * 一、引子
     * 在Java世界里，99%的工作都是处理着高层。那么二进制，字节码这些会在哪里用到呢？
     *
     * 自问自答：在跨平台的时候，就凸显神功了。比如说文件读写，数据通信，还有Java编译后的字节码文件。下面会有个数据通信的例子。
     *
     * Java对对象实现Serializablle接口，就可以将其转化为一系列字节，而在通信中，不必要关系数据如何在不同机器表示和字节的顺序。
     * 这里泥瓦匠对Serializablle接口，不做详细讲解，以后单独详解。
     */

    /*
     * 二、Java进制转换
     *
     * 首先认识下Java中的数据类型：
     *
     * -----------------------
     *
     * 1、Int整型：byte（8位，-128~127）、short（16位）、int（32位）、long（64位）
     *
     * 2、Float型：float（32位）、double（64位）
     *
     * 2、char字符：unicode字符（16位）
     *
     * -----------------------
     *
     * 也就是说，一个int等价于长度为4的字节数组。
     *
     * Java中进制如何转换呢？
     *
     * 在Java中，Int整形以及char字符型被包装的类中提供了一系列的操作方法。
     * 比如 java.lang.Integer 中。
     *
     * System.out.println("17的十六进制： " + Integer.toHexString(17));
     * System.out.println("17的八进制：     " 	+ Integer.toOctalString(17));
     * System.out.println("17的二进制：     " 	+ Integer.toBinaryString(17));
     *
     * System.out.println(Integer.valueOf("11", 16));
     * System.out.println(Integer.valueOf("21", 8));
     * System.out.println(Integer.valueOf("00010001", 2));
     */

    /*
     * 三、Java基本类型和字节神奇转换
     *
     * 这里泥瓦匠想到了自己是个学生，典型的OO思想。那学号：1206010035是整型，怎么转成字节呢，
     * 上面说的拥有字节码的对象能通信。所以，学校关于学号这个都是这样的方式通信的。因此，要将学号转成字节码才行。
     */

    /**
     * Int转字节数组
     *
     * 1、(inta >> i * 8) & 0xff
     *
     * 移位 清零从左往右，按8位获取1字节。
     *
     * 2、这里使用的是小端法。地位字节放在内存低地址端，即该值的起始地址。
     * 补充：32位中分大端模式（PPC）和小段端模式（x86）。
     *
     * ------------------------------------------------------------------------------------------------------------------
     * 记得在学计算机原理的时候，了解到计算机内的存储都是利用二进制的补码进行存储的。
     *
     * 复习一下，原码反码补码这三个概念：
     *
     * 对于正数（00000001）原码来说，首位表示符号位，反码 补码都是本身
     * 对于负数（100000001）原码来说，反码是对原码除了符号位之外作取反运算即（111111110），补码是对反码作+1运算即（111111111）
     * ------------------------------------------------------------------------------------------------------------------
     * 补充：0xff
     *
     * 当将-127赋值给a[0]时候，a[0]作为一个byte类型，其计算机存储的补码是10000001（8位）。
     * 将a[0] 作为int类型向控制台输出的时候，jvm作了一个补位的处理，因为int类型是32位所以补位后的补码就是
     * 1111111111111111111111111 10000001（32位），这个32位二进制补码表示的也是-127.
     *
     * 发现没有，虽然byte->int计算机背后存储的二进制补码由10000001（8位）
     * 转化成了1111111111111111111111111 10000001（32位）很显然这两个补码表示的十进制数字依然是相同的。
     *
     * 但是我做byte->int的转化 所有时候都只是为了保持 十进制的一致性吗？
     * 不一定吧？好比我们拿到的文件流转成byte数组，难道我们关心的是byte数组的十进制的值是多少吗？我们关心的是其背后二进制存储的补码吧
     *
     * 所以大家应该能猜到为什么byte类型的数字要&0xff再赋值给int类型，其本质原因就是想保持二进制补码的一致性。
     *
     * 当byte要转化为int的时候，高的24位必然会补1，这样，其二进制补码其实已经不一致了，&0xff可以将高的24位置为0，低8位保持原样。
     * 这样做的目的就是为了保证二进制数据的一致性。
     *
     * 当然拉，保证了二进制数据性的同时，如果二进制被当作byte和int来解读，其10进制的值必然是不同的，因为符号位位置已经发生了变化。
     *
     * 象例2中，int c = a[0]&0xff;  a[0]&0xff=1111111111111111111111111 10000001&11111111=000000000000000000000000 10000001 ，
     * 这个值算一下就是129，
     *
     * 所以c的输出的值就是129。有人问为什么上面的式子中a[0]不是8位而是32位，因为当系统检测到byte可能会转化成int或者说byte与int类型进行运算的时候，
     * 就会将byte的内存空间高位补1（也就是按符号位补位）扩充到32位，再参与运算。上面的0xff其实是int类型的字面量值，所以可以说byte与int进行运算。
     * ------------------------------------------------------------------------------------------------------------------
     */
    private static byte[] int2Bytes(int inta) {
        // 32位Int可存于长度为4的字节数组
        byte[] bytes = new byte[4];
        for (int i = 0; i < bytes.length; i++) {
            // 移位和清零
            // >> 8 获取一个字节
            bytes[i] = (byte) (int) ((inta >> i * 8) & 0xff);
        }
        return bytes;
    }

    /**
     * 字节数组转Int
     */
    private static int bytes2Int(byte[] bytes) {
        int inta = 0;
        for (int i = 0; i < bytes.length; i++) {
            // 移位和清零
            inta += ((bytes[i] & 0xff) << i * 8);
        }
        return inta;
    }

    private static void test01() {
        // 将我的学号转换成字节码
        byte[] bytes = int2Bytes(1206010035);
        System.out.println(bytes[0] + " " + bytes[1] + " " + bytes[2] + " " + bytes[3]);
        // 字节码就可以转换回学号
        System.out.println(bytes2Int(bytes));
    }

    /**
     * long 转 byte数组
     */
    public static byte[] long2Bytes(long longa) {
        // 64位
        byte[] bytes = new byte[8];
        for (int i = 0; i < bytes.length; i++) {
            // 移位和清零
            // 移动8位获取一个字节，一个字节占8位
            bytes[i] = (byte) (long) (((longa) >> i * 8) & 0xff);
        }
        return bytes;
    }

    /**
     * byte数组 转 long
     */
    public static long bytes2Long(byte[] bytes) {
        long longa = 0;
        for (int i = 0; i < bytes.length; i++) {
            // 移位和清零
            longa += (long) ((bytes[i] & 0xff) << i * 8);
        }
        return longa;
    }

    /*
     * 四、浅谈Java通信中的数据
     *
     * 1、对象实现Serializable接口。
     *    实现了Serializable接口的对象，可将它们转换成一系列字节，并可在以后完全恢复回原来的样子。
     *
     * 2、其学号属性值 1206010035，由客户端转换为字节码。
     *
     * 3、字节码传输至服务端
     *
     * 4、服务端接收并转换为对象属性值。
     */

    public static void main(String[] args) {
        test01();
    }
}
